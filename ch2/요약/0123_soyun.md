# Kotlin 기초

## 코틀린 문법, 특성

-   파라미터 이름 뒤 그 파라미터 타입 작성
-   여러가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 wrapper 제공 ex) Sysmtem.out.println -> println
-   자바와 다른 점
    -   함수를 최상위 수준에 정의 가능 : 자바와 달리 클래스 안에 함수를 정의 할 필요 X
    -   배열 처리를 위한 문법이 존재X
    -   세미콜론을 붙이지 않아도 된다.

### 시작문(statement)과 식(expression)

-   식: 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여 가능
-   문: 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다
-   자바에서는 모든 제어구조가 문이며 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식
    -   ex) 코틀린에서의 if는 식, 대입 문의 경우 자바에서는 식이며 코틀린에서는 문

## 함수

-   함수 선언은 fun 키워드로 시작
-   블록이 본문인 함수 : 블록이 본문인 함수본문이 중괄호로 둘러싸인 함수(인텔리J Tip: Convert to block body)
    -   fun 함수이름(파라미터 목록): 반환 타입 { 함수 본문 }
-   식이 본문인 함수: 등호와 식으로 이루어진 함수(인텔리J Tip: Convert to expression body), 등호를 식 앞에 붙이면 더 간결하게 함수 표현 가능

```
    fun 함수이름(파라미터 목록): 반환 타입 = 함수 본문
```

## 변수

-   자바의 경우 변수 선언시 타입을 맨 앞에 작성, 하지만 코틀린의 경우 타입 지정 생략 가능
-   초기화 식을 사용하지 않고 변수 선언 시 변수 타입 반드시 명시: 변수에 저장될 값에 대해 아무런 정보가 없어 컴파일러가 타입 추론 불가능, 그래서 타입 이 경우 반드시 타입 지정

### 변경 가능(mutable)한 변수와 변경 불가능(immutable)한 변수

-   val(value)
    -   변경 불가능한 참조, 초기화 후 재대입 불가능, 자바에서의 final 변수에 해당
    -   블록을 실행할 때 한번만 초기화 가능
    -   객체 내부 값은 변경 가능 ex) list 등의 타입에서
-   var(variable)
    -   변경 가능한 참조, 자바에서의 일반 변수에 해당
    -   변수 값 변경 가능 but 변수 타입은 고정으로 변경 불가능

## 타입 추론(Type Interface)

-   컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소 타입을 정해주는 기능
-   식이 본문인 함수에서 반환 타입을 생략할 수 있는 이유: 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해주기 때문
-   컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론하며 변수 선언 이후 변수 재대입이 이뤄질 경우 이미 추론한 변수 타입 염두에 두고 대입문 타입 검사

## 문자열 템플릿(String Template)

-   자바의 문자열 접합 연산("Hello"+name+"!")과 동일한 기능으로 효율적 그리고 그것보다 좀 더 간결
-   $변수 이런 식으로 문자열과 사용하는 데 '$' 문자를 문자열에 넣고 싶으면 \\을 사용해 '$'을 escape 시켜야 함
-   unresolved reference error: 코틀린에서는 자바와 마찬 가지로 변수이름에 한글이 들어갈 수 있어 $로 변수 지정 시 변수명 바로 뒤에 한글을 붙여서 사용하면 코틀린 컴파일러가 영문자와 한글을 한꺼번에 식별자로 인식해 해당 오류가 발생할 수 있다. 그래서 변수이름을 {}로 감싸는 것을 추천

## 클래스(Class)와 프로퍼티(Property)

### 클래스(Class)

-   목적: 데이터를 캡슐화(encapsulate)하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것
-   값 객체(value object) : 코드가 없이 데이터만 저장하는 클래스 ex) class Person(val name: String)
-   접근자 메서드(accessor method): 클래스가 자신을 사용하는 클라이언트에게 그 데이터에 접근하는 통로로 쓸 수 있게 제공하는 메서드
-   자바
    -   데이터를 필드(field)에 저장
    -   멤버 필드의 가시성은 보통 비공개(private)
-   코틀린의 기본 가시성은 public으로 변경자 생략 가능

### 프로퍼티(Property)

-   자바에서는 필드와 접근자를 묶어 프로퍼티라 부른다.
-   코틀린에서는 자바의 필드와 접근자 메서드를 완전히 대신 가능 : 비공개 필드, 세터(필드 값 저장). 게터(필드 값 읽기)로 이뤄진 디폴트 접근자 구현 제공
-   뒷받침 필드(backing field): 프로퍼티의 값을 저장하기 위한 필드

### 커스텀 접근자

```
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
    get() {
        return height == width
    }
}
```

-   프로퍼티에 자체 값을 저장하는 필드가 필요 헚으며 자체 구현을 제공하는 게터가 존재. 클라이언트가 프로퍼티 접근 시 프로퍼티 값을 매번 계산
-   파라미터가 없는 함수 정의 방식과 커스텀 게터를 정의하는 방식의 구현이나 성능상 차이는 없고 가독성 차이만 존재.

### 디렉토리와 패키지

-   같은 패키지에 속해 있을 경우 다른 파일에서 정의한 선언이라도 직접 사용가능
-   다른 패키지에 정의한 선언 사용시 임포트를 통해 선언(임포트는 파일의 맨 앞 위치, import 키워드 사용)
-   자바와 달리 클래스 임포트와 함수 임포트에 차이 X, 모든 선언을 import 키워드로 가져올 수 있음
-   디렉토리 구조 차이
    -   자바: 패키지의 구조와 일치하는 디렉터리 계층 구조를 만들고 클래스의 소스코드를 그 클래스가 속한 패키지와 같은 디렉토리에 위치시켜야 함
    -   코틀린: 디스크상의 어느 디렉토리에 소스코드 파일을 위치 시키든 관계X
    -   자바와 코틀린을 함께 사용하는 프로젝트에서는 자바 방식을 따르는 게 중요: 자바 클래스를 코틀린 클래스로 마이그레이션할 때 문제 발생 가능

## 선택 표현과 처리

### enum

-   코틀린에서의 소프트 키워드(soft keyword)라 불림
-   단순히 값만 열거하는 것이 아닌 해당 클래스 안에 프로퍼티나 메서드 정의 가능
-   enum 클래스 안에 메서드 정의 시 반드시 enum 상수 목록과 메서드 정의 사이에 세미콜론 삽입 필수

### when

-   분기 조건이 같지 않으면 다음 분기 조건으로 넘어가며 모든 분기 식에서 만족하는 조건을 찾을 수 없다면 else 분기의 문장을 계산한다.
-   인자가 없는 when 식을 사용
    -   불필요한 객체 생성 막을 수 있다. but 코드 가독성이 떨어지며 성능 향상을 위한 비용 감수가 발생할 수 있다.
    -   when에 아무 인자도 없으려면 각 분기의 조건이 boolean 결과를 계산하는 식이여야 함

### 스마트 캐스트

-   타입 검사와 타입 캐스트 조합
-   변수 타입 검사: 코틀린의 is == 자바의 instance Of
-   변수 타입 캐스팅 과정
    -   자바: 변수의 타입을 instanceOfㅣ로 확인 후 그 타입에 속한 멤버에 접근하기 위해 명시적으로 변수 타입 캐스팅, 이런 멤버 접근 여러 번 수행해야 한다면 변수에 따른 캐스팅한 결과 저장 후 사용해야 함
    -   코틀린의 스마트 캐스트(smart cast) : 프로그래머 대신 컴파일러가 캐스팅, 어떤 변수가 원하는 타입인지 일단 is로 검사 후 변수를 원하는 타입으로 캐스팅하지 않아도 처음부터 그 변수가 원하는 타입으로 선언된 것 처럼 사용 가능
        -   클래스의 프로퍼티에 대해 스마트 캐스트 사용 시 해당 프로퍼티는 반드시 val이어야 하며 커스텀 접근자를 사용한 것이어도 안됨 : 해당 프로퍼티에 대한 접근이 항상 같은 값을 내놓는다고 확신 불가능 해서
        -   명시적으로 타입 캐스팅 시 as 키워드 사용

## 이터레이션(iteration)

-   코틀린 특성 중 자바와 가장 비슷한 특성
-   for 아이템 in 범위 형태로 많이 사용
-   범위
    -   수열(progression): 어떤 범위에 속한 값을 일정한 순서로 이터레이션 하는 경우
    -   시작값..끝값 : 시작값과 끝값을 포함한 범위 ex) 1..5 = 1,2,3,4,5
    -   시작값 downTo 끝값: 역방향 수열 ex) 5 downTo 1 = 5,4,3,2,1
    -   step 숫자: 범위 뒤 붙여주면 범위의 증가 값의 절대값 변경 가능 ex) 5 downTo 1 step 2 = 5,3,1
    -   시작값 until 끝값: 끝값을 포함하지 않는 반만 닫힌 범위(half-closed range, 반폐구간 또는 반개구간) ex) 1 until 5 = 1,2,3,4
-   구조 분해 구문
    -   맵의 경우 키와 값을 동시에 이터레이션 할 수 있다 ex) for((key, value) in map){}
    -   리스트의 경우 원소의 현재 인덱스를 유지하면서 컬렉션을 이터레이션 할 수 있다.ex) for((index, element) in list.withIndex){}
-   in 연산자로 해당 값이 범위 안에 속하는 지 확인 가능

## 예외 처리

-   코틀린의 기본 예외 처리 구문은 자바와 비슷
-   자바와 다른 점
    -   예외 인스턴스를 만들 때 new를 붙일 필요 x
    -   자바와 달리 코틀린의 throw는 식이므로 다른 식에 포함 될 수 있다.

### 체크 예외(checked exception)

-   자바와의 가장 큰 차이: throws 절이 코드에 없다.
-   자바에서 함수 작성 시 함수 선언 뒤 throws IOException을 붙여야 하는 이유: IOException이 체크 예외이기 때문에
-   자바에서의 체크 예외
    -   체크 예외 처리 강제
    -   모두 명시적으로 처리
    -   어떤 함수가 던질 가능성이 있는 예외나 그 함수가 호출한 다른 함수에서 발생할 수 있는 예외를 모두 catch 처리
    -   처리하지 않는 예외는 throws 절에 명시
-   코틀린에서는 체크 예외와 언체크 예외(unchecked exception) 구별 x: 함수가 던지는 예외 지정하지 않고 발생한 예외 잡아내도 되고 안잡아내도 된다.

### try

-   코틀린의 try 키워드는 식: try 값을 변수 대입 가능
-   내부에 여러 문장 있으면 마지막 식 값이 결과 값(catch도 마찬가지)
