1. Kotlin의 val과 var의 차이점을 설명하고 각각 언제 사용하나요?
- val(값): val은 불변 참조를 선언하는 데 사용된다. val이 초기화되면 해당 값을 변경할 수 없다. Java에서 변수를 final로 선언하는 것과 유사하다. 상수 값이나 불변 참조가 필요한 경우 val을 사용해야한다.
var(변수): var은 변경 가능한 참조에 사용된다. var로 선언된 변수는 값이 변경될 수 있다. 루프의 카운터나 동적으로 업데이트되는 프로퍼티과 같이 변수 값이 변경될 것으로 예상되는 경우 var를 사용한다.

2. Kotlin은 Java와 다르게 getter, setter는 어떻게 처리하나요?
- Kotlin에서는 프로퍼티에 대해 getter 및 setter가 자동으로 생성된다. val 경우 getter만 생성된다. var 경우 getter와 setter가 모두 생성된다.
Kotlin에서는 맞춤 getter 및 setter 논리를 프로퍼티 선언 내에서 직접 정의할 수 있으므로 getter 및 setter를 명시적으로 정의해야 하는 Java에 비해 상용구 코드가 줄어든다.

3. Kotlin에서 기본 getter 및 setter가 있는 프로퍼티는 내부적으로 어떻게 구현되나요?
- Kotlin의 기본 getter는 단순히 프로퍼티 값을 반환하고 기본 setter는 프로퍼티에 값을 할당한다. 명시적으로 재정의하지 않는 한 자동으로 생성된다.
내부적으로는 프로퍼티 값을 저장하기 위해 지원 필드가 사용된다. Kotlin의 '필드' 식별자는 이 지원 필드를 나타낸다.


4. Kotlin의 열거형 클래스 개념과 Java의 열거형과 어떻게 다른지 설명해주세요
- Kotlin에서는 'enum' 클래스가 Java보다 더 강력하다. 여기에는 프로퍼티와 메서드가 포함되어 본격적인 클래스가 될 수 있다.
Kotlin의 enum 클래스에는 생성자가 있을 수 있으므로 각 열거형 상수가 생성될 때 프로퍼티를 전달하고 초기화할 수 있지만 Java 열거형의 그렇지 않다.
열거형이 본질적으로 특별한 유형의 클래스인 Java와 달리 Kotlin은 열거형을 보다 간결한 구문과 기능을 갖춘 고유한 구성으로 취급한다.

5. 스마트 캐스트의 한계를 설명하고 언제 작동하지 않는지 설명해주세요
- Kotlin의 스마트 캐스트는 val 또는 검사와 사용 사이에 수정되지 않는 지역 변수에서만 작동한다.
값이 변경될 수 있으므로 변경 가능한 var에서는 작동하지 않으며 이로 인해 컴파일러가 유형 안전성을 보장할 수 없다.
getter가 호출마다 다른 유형을 반환할 수 있으므로 스마트 캐스트는 사용자 지정 getter가 있는 프로퍼티에도 적용할 수 없다.
한 함수에서 변수의 유형을 확인하고 다른 함수에서 사용하는 경우 또는 다른 스레드에서 변수를 변경할 수 있는 경우 스마트 캐스트를 사용할 수 없다.